javax.jdo.PersistenceManagerFactoryClass=org.datanucleus.api.jdo.JDOPersistenceManagerFactory
#datanucleus.ConnectionURL=xml:file:src/test/testData/db/persistent.xml
#datanucleus.ConnectionURL=neodatis:file:src/test/testData/db/neodatisdb.odb

datanucleus.ConnectionDriverName=com.mysql.jdbc.Driver
datanucleus.ConnectionURL=jdbc:mysql://localhost/logicFSLobcder
datanucleus.ConnectionUserName=user
datanucleus.ConnectionPassword=secret
#datanucleus.connectionPoolingType=DBCP

#DataNucleus provides 4 PersistenceManagerFactory properties 
#datanucleus.autoCreateSchema , datanucleus.autoCreateTables , 
#datanucleus.autoCreateColumns , and datanucleus.autoCreateConstraints that 
#allow creation of the datastore tables. This can cause performance issues at 
#startup. We recommend setting these to false at runtime, and instead using 
#SchemaTool to generate any required database schema before running DataNucleus 
#(for RDBMS, HBase) . 
datanucleus.autoCreateTables=true
#datanucleus.autoCreateSchema=true
#datanucleus.autoCreateColumns=true
#datanucleus.autoCreateConstraints=true
datanucleus.DetachAllOnCommit=true
datanucleus.DetachOnClose=true
datanucleus.query.jdoql.allowAll=true
datanucleus.query.sql.allowAll=true

#By default DataNucleus does not currently lock the objects fetched in a 
#pessimistic transaction, but you can configure this behaviour for RDBMS 
#datastores by setting the persistence property datanucleus.SerializeRead to 
#true . This will result in all "SELECT ... FROM ..." statements being changed 
#to be "SELECT ... FROM ... FOR UPDATE". This will be applied only where the 
#underlying RDBMS supports the "FOR UPDATE" syntax. This can be done on a 
#transaction-by-transaction basis by doing tx.setSerializeRead(true);
datanucleus.SerializeRead=true


#dataNucleus allows control over whether objects found by a fetch (JPQL query) 
#are locked during that transaction so that other transactions can't update them 
#in the meantime. You can use the DataNucleus extension 
#datanucleus.rdbms.query.useUpdateLock , set to "true", and this will append 
#"FOR UPDATE" on the end of the SELECT. This can be specified as either a JPQL 
#hint (apply to this query only), or as an EMF property (apply to all queries).
#You can also specify this for all queries for all PMs/EMs using a persistence 
#property datanucleus.rdbms.useUpdateLock . 

javax.jdo.option.Multithreaded=true
javax.jdo.option.NontransactionalRead=true
javax.jdo.option.NontransactionalWrite=false
javax.jdo.option.Optimistic=false


#When you create a PersistenceManagerFactory you define the connection URL, 
#driver name, and the username/password to use. This works perfectly well but 
#does not "pool" the connections so that they are efficiently opened/closed when 
#needed to utilise datastore resources in an optimum way. DataNucleus allows you 
#to utilise a connection pool to efficiently manage the connections to the datastore
# Pooling of Connections
#datanucleus.connectionPool.maxIdle=10
#datanucleus.connectionPool.minIdle=3
#datanucleus.connectionPool.maxActive=5
#datanucleus.connectionPool.maxWait=60
## Pooling of PreparedStatements
#datanucleus.connectionPool.maxStatements=20
#datanucleus.connectionPool.testSQL=SELECT 1
#datanucleus.connectionPool.timeBetweenEvictionRunsMillis=2400000
#datanucleus.connectionPool.minEvictableIdleTimeMillis=18000000

